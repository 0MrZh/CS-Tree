消费者（`Consumer`）负责订阅 `Kafka` 中的主题（`Topic`），并且从订阅的主题上拉取消息。在Kafka的消费理念中还有一层消费组的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。消费者与消费组这种模型可以让整体的消费能力具备横向伸缩性，我们可以增加（或减少）消费者的个数来提高（或降低）整体的消费能力。对于分区数固定的情况，一味地增加消费者并不会让消费能力一直得到提升，如果消费者过多，出现了消费者的个数大于分区个数的情况，就会有消费者分配不到任何分区。

Kafka 同时支持两种消息投递模式：点对点（`P2P`，`Point-to-Point`）模式和发布/订阅（`Pub/Sub`）模式。

- 如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。

- 如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用。

一个正常的消费逻辑需要具备以下几个步骤：

1. 配置消费者客户端参数及创建相应的消费者实例。
2. 订阅主题。
3. 拉取消息并消费。
4. 提交消费位移。
5. 关闭消费者实例。

`Kafka` 中的消费是基于拉模式的，是一个不断轮询的过程，消费者所要做的就是重复地调用 `poll（）` 方法，而 `poll（）` 方法返回的是所订阅的主题（分区）上的一组消息。消费者消费到的每条消息的类型为 `ConsumerRecord` 。`poll()` 内部逻辑而言并不简单，它涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容

在每次调用 `poll（）` 方法时，它返回的是还没有被消费过的消息集，因此需要记录上一次消费时的消费位移，并做持久化保存。在消费者客户端中，消费位移存储在 `Kafka` 内部的主题 `__consumer_offsets` 中。这里把将消费位移存储起来（持久化）的动作称为“提交”，消费者在消费完消息之后需要执行消费位移的提交。

用 `x` 表示某一次拉取操作中此分区消息的最大偏移量，假设当前消费者已经消费了 `x`  位置的消息，那么我们就可以说消费者的消费位移为 `x` 。不过需要非常明确的是，当前消费者需要提交的消费位移并不是 `x` ，而是 `x + 1` ，它表示下一条需要拉取的消息的位置。

