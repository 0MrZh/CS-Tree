## 手撕面试常见基本算法（Java实现）

### 1. 二分查找

```java
public int binarySearch(int[] array, int target) {
    if (array == null || array.length == 0) {
        return -1;
    }
    int l = 0;
    int r = array.length - 1;// 在[l, r]区间进行查找
    while (l <= r) {
        int mid = l + ((r - l) >> 1);// 防止 l + r 溢出
        if (array[mid] == target) {
            return mid;
        }
        if (array[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return -1;
}

```

### 2. 二叉树前序遍历（非递归）

**解法一：**

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {val = x;}
}

public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) {
        return list;
    }
    Stack<TreeNode> stack = new Stack<>();
    TreeNode node = root;
    while (!stack.isEmpty() || node != null) {
        while (node != null) {
            list.add(node.val);
            stack.push(node);
            node = node.left;
        }
        node = stack.pop().right;
    }
    return list;
}
```

**解法二：（贼牛逼）**

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {val = x;}
}

class Command {
    String s; // go 和 print
    TreeNode node;

    Command(String s, TreeNode node) {
        this.s = s;
        this.node = node;
    }
}

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        Stack<Command> stack = new Stack<>();
        stack.push(new Command("go", root));
        while (!stack.isEmpty()) {
            Command command = stack.pop();
            if ("print".equals(command.s)) {
                list.add(command.node.val);
            } else {
                if (command.node.right != null) {
                    stack.push(new Command("go", command.node.right));
                }
                if (command.node.left != null) {
                    stack.push(new Command("go", command.node.left));
                }
                stack.push(new Command("print", command.node));
            }
        }
        return list;
    }
}
```



### 3. 二叉树中序遍历（非递归）

**解法一：**

``` java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {val = x;}
}

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            list.add(node.val);
            node = node.right;
        }
        return list;
    }
}
```

**解法二：**

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {val = x;}
}

class Command {
    String s; // go 和 print
    TreeNode node;

    Command(String s, TreeNode node) {
        this.s = s;
        this.node = node;
    }
}

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        Stack<Command> stack = new Stack<>();
        stack.push(new Command("go", root));
        while (!stack.isEmpty()) {
            Command command = stack.pop();
            if ("print".equals(command.s)) {
                list.add(command.node.val);
            } else {
                if (command.node.right != null) {
                    stack.push(new Command("go", command.node.right));
                }
                stack.push(new Command("print", command.node));
                if (command.node.left != null) {
                    stack.push(new Command("go", command.node.left));
                }
            }
        }
        return list;
    }
}
```



### 4. 二叉树后序遍历（非递归）

**解法一：**

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {val = x;}
}

public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        TreeNode r = null;// 记录节点是否被访问过
        while (!stack.isEmpty() || node != null) {
            while (node != null) {// 左子树下沉
                stack.push(node);
                node = node.left;
            }
            node = stack.peek().right;// 访问右子树
            if (node == null || node == r) {// 当前节点不可以访问
                node = stack.pop(); // 回退到父节点
                list.add(node.val);
                r = node;
                node = null;
            }
        }
        return list;
    }
}
```

**解法二：**

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) {val = x;}
}

class Command {
    String s; // go 和 print
    TreeNode node;

    Command(String s, TreeNode node) {
        this.s = s;
        this.node = node;
    }
}

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        Stack<Command> stack = new Stack<>();
        stack.push(new Command("go", root));
        while (!stack.isEmpty()) {
            Command command = stack.pop();
            if ("print".equals(command.s)) {
                list.add(command.node.val);
            } else {
                stack.push(new Command("print", command.node));
                if (command.node.right != null) {
                    stack.push(new Command("go", command.node.right));
                }
                if (command.node.left != null) {
                    stack.push(new Command("go", command.node.left));
                }
            }
        }
        return list;
    }
}
```

### 5. 删除二叉搜索树中的节点

**代码如下：**

```java
class Solution {
    private TreeNode parent;

    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) {
            return root;
        }
        if (key > root.val) {
            root.right = deleteNode(root.right, key);
        } else if (key < root.val) {
            root.left = deleteNode(root.left, key);
        } else {
            if (root.left == null) {
                return root.right;
            }
            if (root.right == null) {
                return root.left;
            }
            root.right = deleteMin(root, root.right);
        }
        return root;
    }


    private TreeNode deleteMin(TreeNode root, TreeNode node) {
        if (node.left == null) {
            root.val = node.val;
            return node.right;
        }
        node.left = deleteMin(root, node.left);
        return node;
    }
}
```

### 6. 将有序数组转换为二叉搜索树

**代码如下：**

```java
public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        return toBST(nums, 0, nums.length - 1);
    }
    
    private TreeNode toBST(int[] nums, int start, int end) {
        if (start == end) {
            return new TreeNode(nums[start]);
        }
        if (start > end) {
            return null;
        }
        int mid = (start + end) >> 1;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = toBST(nums, start, mid - 1);
        root.right = toBST(nums, mid + 1, end);
        return root;
    }
```

### 7. 二叉搜索树中第K小的元素

**代码如下：**

``` java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int count = 0;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            count++;
            if (k == count) {
                return node.val;
            }
            node = node.right;
        }
        throw new IllegalArgumentException();
    }
}
```

### 8. 二叉树的最近公共祖先

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) {
            return root;
        }
        if (left == null) {
            return right;
        }
        return left;
    }
}
```

